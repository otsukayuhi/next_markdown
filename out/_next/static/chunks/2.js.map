{"version":3,"file":"static/chunks/2.js","sources":["webpack:///./src/markdown/es2015.md"],"sourcesContent":["export default \"# ECMAScript2015+の基礎知識\\n\\n**React / Next.js**を使いこなすためには、**ECMAScript2015+**の知識が必要です。  \\nReactの学習を始めるまえに、おさらいしておきましょう。\\n\\n## 定数と変数\\n- 定数 `const`\\n  - ブロックスコープの再代入不可な定数\\n\\n```js\\n{\\n  const text = 'テキスト';\\n  console.log(text); // -> テキスト\\n\\n  text = '違うテキスト'; // -> Error: \\\"text\\\" is read-only\\n}\\n\\nconsole.log(text); // -> ReferenceError: text is not defined\\n```\\n\\n- 変数 `let`\\n  - ブロックスコープの再代入可能な変数\\n\\n```js\\n{\\n  let num = 0;\\n  console.log(num); // -> 0\\n\\n  num = 1;\\n  console.log(num); // -> 1\\n}\\n\\nconsole.log(num); // ReferenceError: num is not defined\\n```\\n\\n- 変数 `var`\\n  - ブロックスコープではない変数\\n  - `const`と`let`を使っていきましょう \\n\\n```js\\n{\\n  var text = 'テキスト';\\n}\\n\\nconsole.log(text); // -> テキスト\\n```\\n\\n## テンプレートリテラル\\n\\n### ES5の書き方\\n\\n```js\\nconst age = '11歳';\\nconsole.log('私の年齢は' + age + 'です！');\\n// -> 私の年齢は11歳です！\\n```\\n\\n### テンプレートリテラル\\n\\n```js\\nconst age = '11歳';\\nconsole.log(`私の年齢は${age}です！`);\\n// -> 私の年齢は11歳です！\\n```\\n\\n## 分割代入\\n\\n### 配列\\n\\n```js\\nconst member = ['ネズミ', '牛', 'トラ', 'うさぎ'];\\nconst [a, b, c, d] = member;\\n\\nconsole.log(a); // -> ネズミ\\nconsole.log(c); // -> トラ\\n```\\n\\n### オブジェクト\\n\\n```js\\nconst person = {\\n  name: '大塚',\\n  age: 3\\n};\\n\\nconst {name, age} = person;\\n\\nconsole.log(name); // -> 大塚\\nconsole.log(age); // -> 3\\n```\\n\\n## アロー関数\\n\\n### 関数宣言\\n\\n```js\\nfunction foo(a, b) {\\n  return a + b;\\n};\\n\\nconsole.log(foo(1, 2)); // -> 3\\n```\\n\\n### アロー関数\\n\\n```js\\nconst bar = (a, b) => {\\n  return a + b;\\n};\\n\\nconsole.log(bar(1, 2)); // -> 3\\n```\\n\\n### アロー関数の省略\\n\\n```js\\n// 引数が1つの場合、()を省略できる\\n// 返り値のみの場合、{}とreturnを省略できる\\nconst text = age => `私の年齢は${age}です！`;\\n\\nconsole.log(text('11歳')); // -> 私の年齢は11歳です！\\n```\\n\\n### 引数の分割代入\\n\\n```js\\n// オブジェクトを引数に取る場合、分割代入の記法が使える\\nconst text = ({name, age}) => `私の名前は${name}、年齢は${age}歳です！`;\\n\\nconst person = {\\n  name: '大塚',\\n  age: 3\\n};\\n\\nconsole.log(text(person)); // -> 私の名前は大塚、年齢は3歳です！\\n```\\n\\n## map\\n\\n第一引数のcallback関数を、配列の順番通りに各要素に対して1度ずつ呼び出し、その結果から新しい配列を生成する。\\n\\n```js\\nconst member = ['ネズミ', '牛', 'トラ', 'うさぎ'];\\n\\nconst greeting = member.map((name) => {\\n  // nameには'ネズミ'や'牛'が入っている\\n  return `${name}です！`;\\n});\\n\\nconsole.log(greeting);\\n// -> ['ネズミです！', '牛です！', 'トラです！', 'うさぎです！']\\n```\\n\\n## スプレッド構文\\n\\n### 配列\\n\\n```js\\nconst newMember = ['黒猫','三毛猫','茶トラ猫'];\\nconst member = ['ネズミ', '牛', 'トラ', ...newMember];\\n\\nconsole.log(member);\\n// -> ['ネズミ', '牛', 'トラ', '黒猫','三毛猫','茶トラ猫']\\n```\\n\\n### オブジェクト\\n\\n```js\\nconst addProperty = {\\n  country: 'Japan',\\n  hobby: 'music'\\n}\\n\\nconst person = {\\n  name: '大塚',\\n  age: 3,\\n  ...addProperty\\n};\\n\\nconsole.log(person);\\n// -> {name: '大塚', age: 3, country: 'Japan', hobby: 'music'}\\n```\\n\\n### 関数の可変長引数\\n\\n```js\\nconst greeting = (...member) => member.map(name => `私は${name}です！`);\\n\\nconsole.log(greeting('ネズミ', '牛', 'トラ', 'うさぎ'));\\n// -> ['私はネズミです！', '私は牛です！', '私はトラです！', '私はうさぎです！']\\n```\\n\\n## ES Modules\\n\\n`export default` でデータを、グローバルオブジェクトに追加することなく、他のJavaScriptファイルへ出力できます。  \\n\\n```js\\n// foo.js\\nexport default 'テキスト';\\n```\\n\\n```js\\n// index.js\\nimport foo from \\\"./foo\\\";\\n\\nconsole.log(foo); // テキスト\\n```\\n\\nこれでもOK。\\n\\n```js\\n// foo.js\\nconst text = 'テキスト';\\n\\nexport default text;\\n```\\n\\n```js\\n// index.js\\n// textじゃなくてもOK\\nimport foo from \\\"./foo\\\";\\n\\nconsole.log(foo); // テキスト\\n```\\n\\n複数`export`する場合。\\n\\n```js\\n// foo.js\\n// 数値\\nexport const num = 1;\\n\\n// 配列\\nexport const member = ['ネズミ', '牛'];\\n\\n// オブジェクト\\nexport const person = {\\n  name: '大塚',\\n  age: 3\\n};\\n\\n// 関数\\nexport const foo = (a, b) => a + b;\\n```\\n\\n```js\\n// index.js\\nimport { num, member, person, foo } from \\\"./foo\\\";\\n\\nconsole.log(num); // 1\\nconsole.log(member); // ['ネズミ', '牛']\\nconsole.log(person); // { name: '大塚', age: 3 }\\nconsole.log(foo(1, 2)); // 3\\n```\\n\\n`* as moduleName`で、まとめることもできる。\\n\\n```js\\n// index.js\\nimport * as fooModule from \\\"./foo\\\";\\n\\n// fooModuleにオブジェクト形式で格納されている\\nconst { num, member, person, foo } = fooModule;\\n\\nconsole.log(num); // 1\\nconsole.log(member); // ['ネズミ', '牛']\\nconsole.log(person); // { name: '大塚', age: 3 }\\nconsole.log(foo(1, 2)); // 3\\n```\\n\\n```js\\n// index.js\\n// num を number に変えている\\nimport { num as number } from \\\"./foo\\\";\\n\\nconsole.log(number); // 1\\n```\\n\\n`export default`と`export`は併用できる。\\n\\n```js\\n// foo.js\\n// 数値\\nexport const num = 1;\\n\\n// 配列\\nexport const member = ['ネズミ', '牛'];\\n\\n// オブジェクト\\nexport const person = {\\n  name: '大塚',\\n  age: 3\\n};\\n\\n// 関数 (export default)\\nconst foo = (a, b) => a + b;\\n\\nexport default foo;\\n```\\n\\n```js\\n// index.js\\nimport foo, { num, member, person } from \\\"./foo\\\";\\n\\nconsole.log(num); // 1\\nconsole.log(member); // ['ネズミ', '牛']\\nconsole.log(person); // { name: '大塚', age: 3 }\\nconsole.log(foo(1, 2)); // 3\\n```\\n\\nこれもOK。\\n\\n```js\\n// index.js\\nimport foo, * as fooModule from \\\"./foo\\\";\\n\\nconst { num, member, person } = fooModule;\\n\\nconsole.log(num); // 1\\nconsole.log(member); // ['ネズミ', '牛']\\nconsole.log(person); // { name: '大塚', age: 3 }\\nconsole.log(foo(1, 2)); // 3\\n```\""],"mappings":";;;;;;;;;;AAAA;AAAA;;;;A","sourceRoot":""}